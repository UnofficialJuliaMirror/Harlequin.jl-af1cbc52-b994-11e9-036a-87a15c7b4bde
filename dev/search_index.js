var documenterSearchIndex = {"docs":
[{"location":"examples/#Practical-examples-1","page":"Practical examples","title":"Practical examples","text":"","category":"section"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"In this section, we present a number of examples that show how to use Harlequin in a number of practical situations. All the examples are meant to be short and easy to follow; the ideas provided here can help the reader in build more complex scripts and simulations.","category":"page"},{"location":"examples/#Scanning-strategy-1","page":"Practical examples","title":"Scanning strategy","text":"","category":"section"},{"location":"examples/#Creating-a-scanning-strategy-1","page":"Practical examples","title":"Creating a scanning strategy","text":"","category":"section"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"In this exercise, we take the definition of the scanning strategy of a CMB space mission and create a ScanningStrategy object.","category":"page"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"We choose the scanning strategy devised for the PICO mission proposal (Hanany, 2019), described in Sect. 4.1.2. Once we have created the object, we use the Plots package to draw a diagram:","category":"page"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"using Harlequin # hide\nsstr = ScanningStrategy(\n    spin_rpm = 1,\n    prec_rpm = 1 / (10 * 60),      # Precession period is 10 hr\n    hwp_rpm = 0.0,                 # No half-wave plate for PICO\n    spinsunang_rad = deg2rad(26),\n    borespinang_rad = deg2rad(69),\n)\n\nusing Plots # hide\nplot(sstr)","category":"page"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"This matches Fig. 4.2 in the PICO report.","category":"page"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"Note that Harlequin already provides a few [ScanningStrategy] objects for some notable CMB space proposals (see Pre-defined scanning strategies).","category":"page"},{"location":"examples/#Generating-a-sequence-of-pointings-1","page":"Practical examples","title":"Generating a sequence of pointings","text":"","category":"section"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"You can use the function genpointings! to produce a matrix containing the colatitude, longitude, and polarization angle for each sample in a span of time.","category":"page"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"In the following example we generate 5 minutes of data, using the scanning strategy of the CORE mission proposal and assuming that the beam is along the boresight direction. We sample the pointing direction once every 0.1 s:","category":"page"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"using Harlequin # hide\nusing Plots\n\ntime_span = 0 : 0.1 : 5 * 60\nresult = genpointings(\n    CORE_SCANNING_STRATEGY,\n    time_span,\n    Float64[0, 0, 1],         # Beam direction\n    0.0,                      # Start value for the polarization angle psi\n)\n\ntheta, phi, psi, x, y, z = (result[:, colidx] for colidx in 1:6)\n\nplot(time_span, rad2deg.(theta), label=\"\",\n     xlabel=\"Time [s]\", ylabel=\"Colatitude [deg]\")","category":"page"},{"location":"examples/#Producing-a-hit-map-1","page":"Practical examples","title":"Producing a hit map","text":"","category":"section"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"Producing a hit map usually requires to consider huge spans of time. Therefore, it is advisable to pre-allocate the pointing matrix and use genpointings! instead of genpointings within a for loop.","category":"page"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"We follow the example above (Generating a sequence of pointings), but this time we use the PICO scanning strategy. We simulate one day of observations with a beam aligned along the boresight direction, and we produce a Healpix map with NSIDE = 256, using the Healpix.jl package. Note that we take advantage of SegmentedTimeSpan to split the day into segments of 24 hours.","category":"page"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"using Harlequin # hide\nusing Healpix\nusing Plots     # To use \"plot\" with Healpix maps\n\nsts = SegmentedTimeSpan(\n    start_time = 0.0,\n    sampling_time = 0.1,\n    segment_duration = 3600,  # One hour\n    num_of_segments = 24,     # One day of observations\n)\n\nhitmap = Map{Float16, RingOrder}(256)\n\nbeam_dir = Float64[0, 0, 1]   # Boresight direction\n\npointings = Array{Float64}(undef, length(sts[1]), 6)\n\n# Loop over each hour\nfor cur_timespan_s in sts\n    genpointings!(\n        PICO_SCANNING_STRATEGY, \n        cur_timespan_s, \n        beam_dir, \n        0.0, \n        pointings,   # The result is saved here\n    )\n\n    # Project the pointings on the sky sphere\n    theta, phi = (pointings[:, colidx] for colidx in (1, 2))\n    pixidx = ang2pix.(Ref(hitmap), theta, phi)\n    hitmap[pixidx] .= 1\nend\n\n# Show the hitmap\nplot(hitmap)","category":"page"},{"location":"examples/#Estimating-the-fraction-of-sky-covered-by-a-scanning-strategy-1","page":"Practical examples","title":"Estimating the fraction of sky covered by a scanning strategy","text":"","category":"section"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"In this example, we produce a plot which shows the fraction of the sky covered by the CORE scanning strategy as a function of time. It takes a number of ideas from the examples shown above.","category":"page"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"using Harlequin # hide\nusing Healpix\nusing Plots\n\nsts = SegmentedTimeSpan(\n    start_time = 0.0,\n    sampling_time = 0.1,\n    segment_duration = 60,   # One minute\n    num_of_segments = 60,    # One hour of observations\n)\n\nhitmap = Map{Float16, RingOrder}(512)\n\nbeam_dir = Float64[0, 0, 1]   # Boresight direction\n\npointings = Array{Float64}(undef, length(sts[1]), 6)\n\nmins = Int64[]  # This will hold the minutes (X axis of the plot)\nfsky = Float64[] # This will hold the sky fraction (Y axis)\n\n# Loop over each minute\nfor (cur_min, cur_timespan_s) in enumerate(sts)\n    genpointings!(\n        CORE_SCANNING_STRATEGY, \n        cur_timespan_s, \n        beam_dir, \n        0.0, \n        pointings,   # The result is saved here\n    )\n\n    # Project the pointings on the sky sphere\n    theta, phi = (pointings[:, colidx] for colidx in (1, 2))\n    pixidx = ang2pix.(Ref(hitmap), theta, phi)\n    hitmap[pixidx] .= 1\n    \n    cur_fsky = length(hitmap[hitmap .> 0]) / length(hitmap)\n    push!(mins, cur_min)\n    push!(fsky, cur_fsky)\nend\n\n# Show the hitmap\nplot(mins, fsky .* 100, label=\"\",\n     xlabel=\"Time [min]\", ylabel=\"Sky fraction [%]\")","category":"page"},{"location":"examples/#Noise-simulations-1","page":"Practical examples","title":"Noise simulations","text":"","category":"section"},{"location":"examples/#Running-a-Monte-Carlo-simulation-1","page":"Practical examples","title":"Running a Monte Carlo simulation","text":"","category":"section"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"To be written!","category":"page"},{"location":"examples/#Map-making-1","page":"Practical examples","title":"Map-making","text":"","category":"section"},{"location":"examples/#","page":"Practical examples","title":"Practical examples","text":"To be written!","category":"page"},{"location":"genpointings/#Pointing-generation-1","page":"Pointing generation","title":"Pointing generation","text":"","category":"section"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"One of the most basic facilities provided by CMBMissionSim is the generation of pointing timelines. CMBMissionSim assumes that the spacecraft orbits around the L2 Lagrangean point of the Sun-Earth system, and that it performs a monotonous spin around some axis, optionally with some precession period. This is a quite rigid scheme, but it is the one followed by Planck, CORE, and LiteBIRD.","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"The basic object used to create pointings is the ScanningStrategy structure. You can build a ScanningStrategy object using one of its constructors. The most basic one takes the following syntax:","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"ScanningStrategy(;\n    spin_rpm = 0,\n    prec_rpm = 0,\n    yearly_rpm = 1  / (MINUTES_PER_DAY * DAYS_PER_YEAR),\n    hwp_rpm = 0,\n    spinsunang_rad = deg2rad(45.0),\n    borespinang_rad = deg2rad(50.0),\n)","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"Note that this constructor only takes keywords, and that the measurement units used for them are different from the ones used in the fields in ScanningStrategy. Units in the constructors have been chosen in order to be easy to use, while units in ScanningStrategy allow to make computations more efficient.","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"Another kind of constructor allows to load the scanning strategy definition from a JSON file. It comes in two flavours:","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"# First version: pass a file object to `ScanningStrategy`\nopen(\"my_scanning_strategy.json\", \"r\") do inpf\n    sstr = ScanningStrategy(inpf)\nend\n\n# Second version (easier): pass the name of the file\nsstr = ScanningStrategy(\"my_scanning_strategy.json\")","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"These JSON files can be created using the function save:","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"sstr = ScanningStrategy(spinsunang_rad = deg2rad(35.0))\nsave(\"my_scanning_strategy.json\", sstr)","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"If you have loaded the Plots.jl package, you can produce a rough diagram of the scanning strategy using the plot function on a ScanningStrategy object:","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"using Harlequin # hide\nusing Plots\nsstr = ScanningStrategy(\n    spinsunang_rad = deg2rad(35.0),\n    borespinang_rad = deg2rad(40.0),\n)\nplot(sstr)\nsavefig(\"sstr_plot.svg\"); nothing # hide","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"(Image: )","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"(Conventionally, the angle between the spin axis and the Sun-Spacecraft direction is indicated with the symbol α, and the angle between the boresight direction and the spin axis with β.)","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"Once you have a ScanningStrategy object, you generate the sequence of pointing directions through one of the following functions:","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"genpointings and genpointings! generate a set of pointing directions that encompass a range of time; most of the time you will use this.\ntime2pointing and time2pointing! generate one pointing direction at a time; they are useful if you are working on a system with limited memory resources.","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"The version with the ! and the end save their result in a preallocated block, while the other ones use the return value of the function. The former is useful if you are using some strategy to pre-allocate memory in order to optimize running times. For instance, the following code is not optimal, as genpointings is re-creating the same result matrix over and over again:","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"const SECONDS_IN_A_HOUR = 3600.\nsstr = ScanningStrategy()\nstart_time = 0.0\n# Simulate an observation lasting 1000 hours\nfor hour_num in 1:1000\n    # Each call to \"genpointings\" allocates a new \"pnt\" matrix:\n    # doing it multiple times like in this \"for\" loop takes time and\n    # slows down the execution!\n    pnt = genpointings(sstr, start_time:(start_time + SECONDS_IN_A_HOUR),\n        Float64[0, 0, 1], 0.0)\n    # Use \"pnt\" here\n    # ...\nend","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"The code below is more efficient, as the allocation is done only once:","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"const SECONDS_IN_A_HOUR = 3600.\nsstr = ScanningStrategy()\nstart_time = 0.0\n\n# Allocate this variable once and for all\npnt = Array{Float64}(undef, SECONDS_IN_A_HOUR, 6)\n\n# Simulate an observation lasting 1000 hours\nfor hour_num in 1:1000\n    # Use \"pnt\" again and again, overwriting it each time: this is\n    # much faster!\n    genpointings!(sstr, start_time:(start_time + SECONDS_IN_A_HOUR),\n        Float64[0, 0, 1], 0.0, pnt)\n    # Use \"pnt\" here\n    # ...\nend","category":"page"},{"location":"genpointings/#ScanningStrategy-1","page":"Pointing generation","title":"ScanningStrategy","text":"","category":"section"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"ScanningStrategy\nupdate_scanning_strategy","category":"page"},{"location":"genpointings/#Harlequin.ScanningStrategy","page":"Pointing generation","title":"Harlequin.ScanningStrategy","text":"The structure ScanningStrategy encodes the information needed to build a set of pointing directions. It contains the following fields:\n\nomega_spin_hz: angular speed of the rotation around the spin axis (equal to 2πν)\nomega_prec_hz: angular speed of the rotation around the precession axis (equal to 2πν)\nomega_year_hz: angular speed of the rotation around the Elliptic axis (equal to 2πν)\nomega_hwp_hz: angular speed of the rotation of the half-wave plate (equal to 2πν)\nspinsunang_rad: angle between the spin axis and the Sun-Earth direction\nborespinang_rad: angle between the boresight direction and the spin axis\nq1, q3: quaternions used to generate the pointings\n\nEach field has its measure unit appended to the name. For instance, field spinsunang_rad must be expressed in radians.\n\n\n\n\n\n","category":"type"},{"location":"genpointings/#Harlequin.update_scanning_strategy","page":"Pointing generation","title":"Harlequin.update_scanning_strategy","text":"update_scanning_strategy(sstr::ScanningStrategy)\n\nUpdate the internal fields of a ScanningStrategy object. If you change any of the fields in a ScanningStrategy object after it has been created using the constructors, call this function before using one of the functions time2pointing, time2pointing!, genpointings, and genpointings!, as they rely on a number of internal parameters that need to be updated.\n\nsstr = ScanningStrategy()\n# ... use sstr ...\n\nsstr.borespinang_rad *= 0.5\nupdate_scanning_strategy(sstr)\n\n\n\n\n\n","category":"function"},{"location":"genpointings/#Pre-defined-scanning-strategies-1","page":"Pointing generation","title":"Pre-defined scanning strategies","text":"","category":"section"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"Harlequin includes a few constants for the scanning strategies used by notable CMB proposals.","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"CORE_SCANNING_STRATEGY\nPICO_SCANNING_STRATEGY","category":"page"},{"location":"genpointings/#Harlequin.CORE_SCANNING_STRATEGY","page":"Pointing generation","title":"Harlequin.CORE_SCANNING_STRATEGY","text":"CORE_SCANNING_STRATEGY::ScanningStrategy\n\nA ScanningStrategy object describing the proposed scanning strategy of the CORE spacecraft (Delabrouille et al., 2018).\n\n\n\n\n\n","category":"constant"},{"location":"genpointings/#Harlequin.PICO_SCANNING_STRATEGY","page":"Pointing generation","title":"Harlequin.PICO_SCANNING_STRATEGY","text":"PICO_SCANNING_STRATEGY::ScanningStrategy\n\nA ScanningStrategy object describing the proposed scanning strategy of the PICO spacecraft (Hanany et al., 2019).\n\n\n\n\n\n","category":"constant"},{"location":"genpointings/#Generating-pointings-over-long-periods-of-time-1","page":"Pointing generation","title":"Generating pointings over long periods of time","text":"","category":"section"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"Harlequin provides an handy structure, SegmentedTimeSpan, which can be used to produce the time ranges required by genpointings and genpointings! in a segmented fashion.","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"Suppose you want to simulate the behavior of a spacecraft over one year. As the sampling frequency of the detector is small, one tenth of a second, the pointing matrix returned by genpointings is going to be huge. Usually there is no need to keep all the pointing matrix at once; typically what you want to keep is the pixel index for each sample and the polarisation angle.","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"In this case, you can divide the overall time span (one year) into small segments and process one of them at a time, using SegmentedTimeSpan. The following example shows the idea: we simulate one day of observations one hour at a time.","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"using Harlequin # hide\nsts = SegmentedTimeSpan(\n    start_time = 0.0,\n    sampling_time = 0.1,\n    segment_duration = 3600,  # One hour\n    num_of_segments = 24,     # One day of observations\n)\n\n# Each element of the \"sts\" array is the sequence of time samples\n# for one day\n\n# Size the pointing matrix according to the first day\npointings = Array{Float64}(undef, length(sts[1]), 6)\n\nfor (hour_number, cur_time_span) in enumerate(sts)\n    println(\"Processing hour #$hour_number, time samples are $cur_time_span\")\n    genpointings!(\n        PICO_SCANNING_STRATEGY,\n        cur_time_span,\n        Float64[0, 0, 1],\n        0.0,\n        pointings,\n    )\n    \n    # \"pointings\" contains the pointings for the current hour\nend","category":"page"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"SegmentedTimeSpan","category":"page"},{"location":"genpointings/#Harlequin.SegmentedTimeSpan","page":"Pointing generation","title":"Harlequin.SegmentedTimeSpan","text":"struct SegmentedTimeSpan\n\nAn immutable structure representing a long time span, split into units of equal length called segments. This structure is typically used to make consecutive calls to genpointings! and genpointings.\n\nThe fields are the following:\n\nstart_time is the time of the first sample in the time span\nsampling_time is the integration time for one sample\nsegment_duration is the duration of one segment\nnum_of_segments is the number of segments in the time span\n\nThe following example defines a time span of 1 year as the composition of multiple spans, each lasting one day:\n\nsts = SegmentedTimeSpan(\n    start_time = 0.0,\n    sampling_time = 0.1,\n    segment_duration = 24 * 3600,\n    num_of_segments = 365,\n)\n\nOnce a SegmentedTimeSpan has been constructed, it behaves like an array, whose elements are time ranges of type StepRangeLen. You can iterate over it, to run functions like genpointings:\n\nfor cur_time_span in sts\n    pointings = genpointings(PICO_SCANNING_STRATEGY, cur_time_span, ...)\n\n    # \"pointings\" contain the pointings for the time span\nend\n\n\n\n\n\n","category":"type"},{"location":"genpointings/#Loading-and-saving-scanning-strategies-1","page":"Pointing generation","title":"Loading and saving scanning strategies","text":"","category":"section"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"load_scanning_strategy\nto_dict\nsave","category":"page"},{"location":"genpointings/#Harlequin.load_scanning_strategy","page":"Pointing generation","title":"Harlequin.load_scanning_strategy","text":"load_scanning_strategy(io::IO) -> ScanningStrategy\nload_scanning_strategy(filename::AbstractString) -> ScanningStrategy\n\nCreate a ScanningStrategy object from the definition found in the JSON file io, or from the JSON file with path filename. See also load_scanning_strategy.\n\n\n\n\n\n","category":"function"},{"location":"genpointings/#Harlequin.to_dict","page":"Pointing generation","title":"Harlequin.to_dict","text":"to_dict(sstr::ScanningStrategy) -> Dict{String, Any}\n\nConvert a scanning strategy into a dictionary suitable to be serialized using JSON or any other structured format. See also save.\n\n\n\n\n\n","category":"function"},{"location":"genpointings/#Harlequin.save","page":"Pointing generation","title":"Harlequin.save","text":"save(io::IO, sstr::ScanningStrategy)\nsave(filename::AbstractString, sstr::ScanningStrategy)\n\nWrite a definition of the scanning strategy in a self-contained JSON file. You can reload this definition using one of the constructors of ScanningStrategy.\n\n\n\n\n\n","category":"function"},{"location":"genpointings/#Pointing-generation-2","page":"Pointing generation","title":"Pointing generation","text":"","category":"section"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"time2pointing\ntime2pointing!\ngenpointings\ngenpointings!","category":"page"},{"location":"genpointings/#Harlequin.time2pointing","page":"Pointing generation","title":"Harlequin.time2pointing","text":"time2pointing!(sstr::ScanningStrategy, time_s, beam_dir, polangle_rad, resultvec)\ntime2pointing(sstr::ScanningStrategy, time_s, beam_dir, polangle_rad)\n\nCalculate the pointing direction of a beam along the direction beam_dir, with a detector sensitive to the polarization along the angle polangle_rad. The result is saved in resultvec for time2pointing!, and it is the return value of time2pointing; it is a 6-element array containing the following fields:\n\nThe colatitude (in radians) of the point in the sky\nThe longitude (in radians) of the point in the sky\nThe polarization angle, in the reference frame of the sky\nThe X component of the normalized pointing vector\nThe Y component\nThe Z component\n\nFields #4, #5, #6 are redundant, as they can be derived from the colatitude (field #1) and longitude (field #2). They are returned as the code already computes them.\n\nThe vector beam_dir and the angle polangle_rad must be expressed in the reference system of the focal plane. If polangle_rad == 0, the detector measures polarization along the x axis of the focal plane. The normal direction to the focal plane is along the z axis; thus, the boresight director is such that beam_dir = [0., 0., 1.].\n\n\n\n\n\n","category":"function"},{"location":"genpointings/#Harlequin.time2pointing!","page":"Pointing generation","title":"Harlequin.time2pointing!","text":"time2pointing!(sstr::ScanningStrategy, time_s, beam_dir, polangle_rad, resultvec)\ntime2pointing(sstr::ScanningStrategy, time_s, beam_dir, polangle_rad)\n\nCalculate the pointing direction of a beam along the direction beam_dir, with a detector sensitive to the polarization along the angle polangle_rad. The result is saved in resultvec for time2pointing!, and it is the return value of time2pointing; it is a 6-element array containing the following fields:\n\nThe colatitude (in radians) of the point in the sky\nThe longitude (in radians) of the point in the sky\nThe polarization angle, in the reference frame of the sky\nThe X component of the normalized pointing vector\nThe Y component\nThe Z component\n\nFields #4, #5, #6 are redundant, as they can be derived from the colatitude (field #1) and longitude (field #2). They are returned as the code already computes them.\n\nThe vector beam_dir and the angle polangle_rad must be expressed in the reference system of the focal plane. If polangle_rad == 0, the detector measures polarization along the x axis of the focal plane. The normal direction to the focal plane is along the z axis; thus, the boresight director is such that beam_dir = [0., 0., 1.].\n\n\n\n\n\n","category":"function"},{"location":"genpointings/#Harlequin.genpointings","page":"Pointing generation","title":"Harlequin.genpointings","text":"genpointings!(sstr::ScanningStrategy, timerange_s, beam_dir, polangle_rad, result)\ngenpointings(sstr::ScanningStrategy, timerange_s, beam_dir, polangle_rad)\n\nGenerate a set of pointing directions and angles for a given orientation beam_dir (a 3-element vector) of the boresight beam, assuming the scanning strategy in sstr. The pointing directions are calculated over all the elements of the list timerange_s. The angle polangle_rad is the value of the polarization angle at time t = 0.\n\nThe two functions only differ in the way the result is returned to the caller. Function genpointings returns a N×6 matrix containing the following fields:\n\nThe colatitude (in radians)\nThe longitude (in radians)\nThe polarization angle (in radians)\nThe X component of the one-length pointing vector\nThe Y component\nThe Z component\n\nFunction genpointings! works like genpointings, but it accept a pre-allocated matrix as input (the result parameter) and will save the result in it. The matrix must have two dimensions with size (N, 6) at least.\n\nBoth functions are simple iterators wrapping time2pointing! and time2pointing.\n\n\n\n\n\n","category":"function"},{"location":"genpointings/#Harlequin.genpointings!","page":"Pointing generation","title":"Harlequin.genpointings!","text":"genpointings!(sstr::ScanningStrategy, timerange_s, beam_dir, polangle_rad, result)\ngenpointings(sstr::ScanningStrategy, timerange_s, beam_dir, polangle_rad)\n\nGenerate a set of pointing directions and angles for a given orientation beam_dir (a 3-element vector) of the boresight beam, assuming the scanning strategy in sstr. The pointing directions are calculated over all the elements of the list timerange_s. The angle polangle_rad is the value of the polarization angle at time t = 0.\n\nThe two functions only differ in the way the result is returned to the caller. Function genpointings returns a N×6 matrix containing the following fields:\n\nThe colatitude (in radians)\nThe longitude (in radians)\nThe polarization angle (in radians)\nThe X component of the one-length pointing vector\nThe Y component\nThe Z component\n\nFunction genpointings! works like genpointings, but it accept a pre-allocated matrix as input (the result parameter) and will save the result in it. The matrix must have two dimensions with size (N, 6) at least.\n\nBoth functions are simple iterators wrapping time2pointing! and time2pointing.\n\n\n\n\n\n","category":"function"},{"location":"genpointings/#Utility-functions-1","page":"Pointing generation","title":"Utility functions","text":"","category":"section"},{"location":"genpointings/#","page":"Pointing generation","title":"Pointing generation","text":"rpm2angfreq\nangfreq2rpm\nperiod2rpm\nrpm2period","category":"page"},{"location":"genpointings/#Harlequin.rpm2angfreq","page":"Pointing generation","title":"Harlequin.rpm2angfreq","text":"rpm2angfreq(rpm)\nangfreq2rpm(ω)\n\nConvert rotations per minute into angular frequency 2πν (in Hertz), and vice versa.\n\n\n\n\n\n","category":"function"},{"location":"genpointings/#Harlequin.angfreq2rpm","page":"Pointing generation","title":"Harlequin.angfreq2rpm","text":"rpm2angfreq(rpm)\nangfreq2rpm(ω)\n\nConvert rotations per minute into angular frequency 2πν (in Hertz), and vice versa.\n\n\n\n\n\n","category":"function"},{"location":"genpointings/#Harlequin.period2rpm","page":"Pointing generation","title":"Harlequin.period2rpm","text":"period2rpm(p)\nrpm2perriod(rpm)\n\nConvert a period (time span) in seconds into a number of rotations per minute, and vice versa.\n\n\n\n\n\n","category":"function"},{"location":"genpointings/#Harlequin.rpm2period","page":"Pointing generation","title":"Harlequin.rpm2period","text":"period2rpm(p)\nrpm2perriod(rpm)\n\nConvert a period (time span) in seconds into a number of rotations per minute, and vice versa.\n\n\n\n\n\n","category":"function"},{"location":"#Harlequin.jl-1","page":"Home","title":"Harlequin.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"DocTestSetup = quote\n    using Harlequin\nend","category":"page"},{"location":"#","page":"Home","title":"Home","text":"A simulator for space CMB missions.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To install Harlequin, start Julia and type the following command:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"https://github.com/ziotom78/Harlequin.jl\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"To run the test suite, type the following command:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Pkg; Pkg.test(\"Harlequin\")","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In this manual, we will often assume that Harlequin has been imported using the following command:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"using Harlequin","category":"page"},{"location":"#Documentation-1","page":"Home","title":"Documentation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The documentation was built using Documenter.jl.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"import Dates: now #hide\nprintln(\"Documentation built $(now()) with Julia $(VERSION).\") # hide","category":"page"},{"location":"#Index-1","page":"Home","title":"Index","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"","category":"page"},{"location":"mapmaking/#Map-making-1","page":"Map-making","title":"Map-making","text":"","category":"section"},{"location":"mapmaking/#","page":"Map-making","title":"Map-making","text":"Harlequin includes a routine that applies the destriping algorithm to time-ordered data, producing a maximum-likelihood map of the intensity and polarization signal.","category":"page"},{"location":"mapmaking/#","page":"Map-making","title":"Map-making","text":"The destriping algorithm used in the code is described in the paper Destiping CMB temperature and polarization maps, Kurki-Suonio et al., A/A 506, 1511-1539 (2009), and the source code closely follows the terminology introduced in that paper.","category":"page"},{"location":"mapmaking/#","page":"Map-making","title":"Map-making","text":"The destriping algorithm is effective in removing 1/f noise originated within the detectors of an instrument, provided that the noise is uncorrelated among detectors. It requires the user to specify a baseline, i.e., the maximum time span in which the noise can be assumed to be uncorrelated (i.e., white).","category":"page"},{"location":"mapmaking/#","page":"Map-making","title":"Map-making","text":"Since the destriper is effective only when much data is available, it is often the case that the input data to be fed to the algorithm is larger than the available memory on a machine. In this case, the destriper can take advantage of a distributed-memory environment and of the MPI libraries, if they have been loaded before Harlequin, like in the following example:","category":"page"},{"location":"mapmaking/#","page":"Map-making","title":"Map-making","text":"import MPI\nimport Harlequin  # Ok, use MPI whenever possible\n\n# ...","category":"page"},{"location":"mapmaking/#","page":"Map-making","title":"Map-making","text":"You can check if MPI is being used with the function use_mpi.","category":"page"},{"location":"mapmaking/#","page":"Map-making","title":"Map-making","text":"Destriping is based on a datatype, DestripingData, and on the function destripe!. To use the destriper, you create an object of type DestripingData and then call destripe! on it. The TOD must be split in a set of observations, using the datatype Observation; we will see how to use them in the section Splitting a TOD into observations.","category":"page"},{"location":"mapmaking/#Splitting-a-TOD-into-observations-1","page":"Map-making","title":"Splitting a TOD into observations","text":"","category":"section"},{"location":"mapmaking/#","page":"Map-making","title":"Map-making","text":"Observation","category":"page"},{"location":"mapmaking/#Harlequin.Observation","page":"Map-making","title":"Harlequin.Observation","text":"mutable struct Observation{T <: Real}\n\nAn observation is a sequence of time-ordered data (TOD) that has been acquired by some detector. It implements the following fields:\n\ntime: an array of N elements, representing the time of the sample. Being defined as an AbstractArray, a range (e.g., 0.0:0.1:3600.0) can be used to save memory\npixidx: an array of N elements, each being a pixel index in a map. In no way the Healpix pixelization scheme is enforced; in fact, the map must not even be spherical.\npsi_angle: an array of N elements, each containing the orientation of the polarization angle with respect to some fixed reference system (e.g., the Ecliptic plane). The angles must be in radians.\ntod: an array of N elements, containing the actual data measured by the instrument and already calibrated to some physical units (e.g., K_CMB)\nsigma_squared: an array of N elements, containing the squared RMS of each sample. To save memory, you should usually use a RunLengthArray here.\nflagged: a Boolean array of N elements, telling whether the sample should be discarded (true) or not (false) during the map-making process.\nname: a string representing the detector. This is used only for debugging purposes.\n\nTo create an observation, the constructor takes keyword arguments instead of parameters; in this way, the code should be more readable. Also, sensible defaults will be provided for the missing fields:\n\n# We do not specify \"sigma_squared\" nor \"flagged\", so they will be\n# initialized to a vector of ones and a vector of `false`\nobs = Observation{Float64}(\n    time = 0.0:0.1:3600.0,\n    pixidx = 1:3601,\n    psi_angle = zeros(3601),\n    tod = randn(3601),\n)\n\n\n\n\n\n","category":"type"},{"location":"mapmaking/#High-level-functions-1","page":"Map-making","title":"High-level functions","text":"","category":"section"},{"location":"mapmaking/#","page":"Map-making","title":"Map-making","text":"DestripingData\ndestripe!\nuse_mpi","category":"page"},{"location":"mapmaking/#Harlequin.DestripingData","page":"Map-making","title":"Harlequin.DestripingData","text":"mutable struct DestripingData{T <: Real, O <: Healpix.Order}\n\nStructure containing the result of a destriping operation. It contains the following fields:\n\nskymap: a PolarizedMap containing the maximum-likelihood map\nhitmap: a map containing the weights of each pixel (this is not the hit count, as it is normalized over the value of σ^2 for each sample in the TOD)\nnobs_matrix: an array of NobsMatrixelement objects, which can be used to determine which pixels were the most troublesome in the reconstruction of tehe I/Q/U components\nbaselines: the computed baselines. These must be kept as a list of RunLengthArray objects\nstopping_factors: sequence of stopping factors, one for each iteration of the CG algorithm\nthreshold: upper limit on the tolerable error for the Conjugated Gradient method (optional, default is 1e-9). See calc_stopping_factor.\nmax_iterations: maximum number of allowed iterations for the Conjugated Gradient algorithm (optional, default is 1000).\nuse_preconditioner: a Boolean flag telling whether a preconditioner should be used or not (optional, default is true). Usually you want this to be true.\n\nThe structure provides only one constructor, which accepts the following parameters:\n\nnside: resolution of skymap and hitmap\nobs_list: vector of Observation; it is used to determine which pixels in the map are going to be observed\nruns: list of vectors (one for each element in obs_list), containing the number of samples to be included in each baseline for each observation\n\nThe constructor accepts the following keywords as well:\n\nthreshold (default: 1e-9)\nmax_iterations (default: 1000)\nuse_preconditioner (default: true)\n\nThe function destripe! use DestripingData to return the result of its computation.\n\n\n\n\n\n","category":"type"},{"location":"mapmaking/#Harlequin.destripe!","page":"Map-making","title":"Harlequin.destripe!","text":"destripe!(obs_list, destriping_data::DestripingData{T,O}; comm, unseen, callback) where {T <: Real, O <: Healpix.Order}\n\nApply the destriping algorithm to the TOD in obs_list. The result is returned in destriping_data, which is of type DestripingData and contains the baselines, I/Q/U maps, weight map, etc.\n\nThe parameters must satisfy the following constraints:\n\nobs_list must be an array of N Observation objects;\ndestriping_data must be a DestripingData object. It does not need to have been initialized using reset_maps!.\n\nThe optional keyword have the following meaning and default value:\n\ncomm is a MPI communicator object, or nothing is MPI is not used.\nunseen is the value to be used for pixels in the map that have not been observed. The default is missing; other sensible values are nothing and NaN.\ncallback is either nothing (the default) or a function that is called before the CG algorithm starts, and then once every iteration. It can be used to monitor the progress of the destriper, or to save intermediate results in a database or a file. The function receives destriping_data as its parameter\n\nThe function uses Julia's Logging module. Therefore, you can enable the output of diagnostic messages as usual; consider the following example:\n\nglobal_logger(ConsoleLogger(stderr, Debug))\n\n# This command is going to produce a lot of output…\ndestripe!(...)\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Harlequin.use_mpi","page":"Map-making","title":"Harlequin.use_mpi","text":"use_mpi()\n\nReturn true if Harlequin is taking advantage of MPI, false if not.\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Low-level-functions-1","page":"Map-making","title":"Low-level functions","text":"","category":"section"},{"location":"mapmaking/#","page":"Map-making","title":"Map-making","text":"The following functions are listed here for reference. You are not expected to use them, unless you want to debug the destriper or dig into its internals.","category":"page"},{"location":"mapmaking/#","page":"Map-making","title":"Map-making","text":"update_nobs!\nupdate_nobs_matrix!\ncompute_nobs_matrix!\nupdate_binned_map!\nreset_maps!\ncompute_z_and_subgroup!\ncompute_z_and_group!\ncompute_residuals!\narray_dot\ncalc_stopping_factor\napply_offset_to_baselines!\ncalculate_cleaned_map!","category":"page"},{"location":"mapmaking/#Harlequin.update_nobs!","page":"Map-making","title":"Harlequin.update_nobs!","text":"update_nobs!(nobs::NobsMatrixElement{T}; threshold = 1e-7)\n\nThis function makes sure that all the elements in nobs are synchronized. It should be called whenever the field nobs.m (matrix M_p in Eq. 10 of KurkiSuonio2009) has changed.\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Harlequin.update_nobs_matrix!","page":"Map-making","title":"Harlequin.update_nobs_matrix!","text":"update_nobs_matrix!(nobs_matrix::Vector{NobsMatrixElement{T}}, psi_angle, sigma_squared, pixidx, flagged)\n\nApply Eq. (10) of KurkiSuonio2009 iteratively on the samples of a TOD to update matrices M_p in nobs_matrix. The meaning of the parameters is the following:\n\nnobs_matrix is the structure that gets updated by this function\npsi_angle is an array of N elements, containing the polarization angles (in radians)\nsigma_squared is an array of N elements, each containing the value of σ^2 for the samples in the TOD\npixidx is an array of N elements, containing the pixel index observed by the TOD\nflagged is a Boolean array of N elements; true means that the sample in the TOD should not be used to produce the map. This can be used to produce jackknives and to neglect moving objects in the TOD\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Harlequin.compute_nobs_matrix!","page":"Map-making","title":"Harlequin.compute_nobs_matrix!","text":"compute_nobs_matrix!(nobs_matrix::Vector{NobsMatrixElement}, observations::Vector{Observation{T}}; comm = nothing)\n\nInitialize all the elements in nobs_matrix so that they are the matrices M_p in Eq. (10) of KurkiSuonio2009. The TOD is taken from the list of observations in the parameter observations.\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Harlequin.update_binned_map!","page":"Map-making","title":"Harlequin.update_binned_map!","text":"update_binned_map!(vec, skymap::PolarizedMap{T, O}, hitmap::Healpix.Map{T, O}, obs::Observation{T}; comm=nothing, unseen=NaN) where {T <: Real, O <: Healpix.Order}\nupdate_binned_map!(skymap::PolarizedMap{T, O}, hitmap::Healpix.Map{T, O}, obs::Observation{T}; comm=nothing, unseen=NaN) where {T <: Real, O <: Healpix.Order}\nupdate_binned_map!(skymap::PolarizedMap{T, O}, hitmap::Healpix.Map{T, O}, obs_list::Vector{Observation{T}}; comm=nothing, unseen=NaN) where {T <: Real, O <: Healpix.Order}\n\nApply Eqs. (18), (19), and (20) to compute the values of I, Q, and U from a TOD, and save the result in skymap and hitmap.\n\nThe three versions differ for the source of the TOD calibrated data:\n\nif the vec parameter is present (first form), it will be used instead of obs.tod (second form)\ninstead of obs (a single Observation object), you can pass an array obs_list (third form). All the elements in this array will be used to update skymap and hitmap.\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Harlequin.reset_maps!","page":"Map-making","title":"Harlequin.reset_maps!","text":"reset_maps!(d::DestripingData{T, O}) where {T <: Real, O <: Healpix.Order}\n\nSet the skymap and the hitmap in d to zero. Nothing is done on the other fields.\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Harlequin.compute_z_and_subgroup!","page":"Map-making","title":"Harlequin.compute_z_and_subgroup!","text":"compute_z_and_subgroup!(dest_baselines, vec, baseline_lengths, destriping_data::DestripingData{T, O}, obs::Observation{T}; comm=nothing, unseen=NaN) where {T, O <: Healpix.Order}\ncompute_z_and_subgroup!(dest_baselines, baseline_lengths, destriping_data::DestripingData{T, O}, obs::Observation{T}; comm=nothing, unseen=NaN) where {T, O <: Healpix.Order}\n\nCompute the application of matrix A in Eq. (25) in KurkiSuonio2009. The result is a set of baselines, and it is saved in dest_baselines (an array of elements whose type is T). The two forms differ only in the presence of the vec parameter: if it is not present, the value of obs.tod will be used.\n\nThis function only operates on single observations. If you want to apply it to an array of observations, use compute_z_and_group!.\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Harlequin.compute_z_and_group!","page":"Map-making","title":"Harlequin.compute_z_and_group!","text":"compute_z_and_group!(dest_baselines, vectors, baseline_lengths, destriping_data::DestripingData{T, O}, obs_list::Vector{Observation{T}}; comm=nothing, unseen=NaN) where {T, O <: Healpix.Order}\ncompute_z_and_group!(dest_baselines, baseline_lengths, destriping_data::DestripingData{T, O}, obs_list::Vector{Observation{T}}; comm=nothing, unseen=NaN) where {T, O <: Healpix.Order}\n\nCompute the application of matrix A in Eq. (25) in KurkiSuonio2009. The result is a set of baselines, and it is saved in dest_baselines (an array of elements whose type is T). The two forms differ only in the presence of the vec parameter: if it is not present, the value of obs.tod will be used.\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Harlequin.compute_residuals!","page":"Map-making","title":"Harlequin.compute_residuals!","text":"compute_residuals!(residuals, baseline_lengths, destriping_data, obs_list; comm=nothing, unseen=missing)\n\nThis function is used to compute the value of A x - b at the beginning of the Conjugated-Gradient algorithm implemented in destripe!.\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Harlequin.array_dot","page":"Map-making","title":"Harlequin.array_dot","text":"array_dot(x, y; comm = nothing)\n\nCompute the dot product between x and y, assuming that both are arrays of arrays.\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Harlequin.calc_stopping_factor","page":"Map-making","title":"Harlequin.calc_stopping_factor","text":"calc_stopping_factor(r; comm=nothing)\n\nCalculate the stopping factor required by the Conjugated Gradient method to determine if the iteration must be stopped or not. The parameter r is the vector of the residuals.\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Harlequin.apply_offset_to_baselines!","page":"Map-making","title":"Harlequin.apply_offset_to_baselines!","text":"apply_offset_to_baselines!(baselines)\n\nAdd a constant offset to all the baselines such that their sum is zero.\n\n\n\n\n\n","category":"function"},{"location":"mapmaking/#Harlequin.calculate_cleaned_map!","page":"Map-making","title":"Harlequin.calculate_cleaned_map!","text":"calculate_cleaned_map!(obs_list, destriping_data; comm=nothing, unseen=missing)\n\nProvided a set of baselines in baselines, this function cleans the TOD in obs_list and computes the I/Q/U maps, which are saved in destriping_data.\n\n\n\n\n\n","category":"function"}]
}
