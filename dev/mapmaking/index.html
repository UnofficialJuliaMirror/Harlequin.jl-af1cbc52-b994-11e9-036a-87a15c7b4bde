<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Map-making · Harlequin.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Harlequin.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Home</a></li><li><a class="toctext" href="../genpointings/">Pointing generation</a></li><li class="current"><a class="toctext" href>Map-making</a><ul class="internal"><li><a class="toctext" href="#Splitting-a-TOD-into-observations-1">Splitting a TOD into observations</a></li><li><a class="toctext" href="#High-level-functions-1">High-level functions</a></li><li><a class="toctext" href="#Low-level-functions-1">Low-level functions</a></li></ul></li><li><a class="toctext" href="../examples/">Practical examples</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Map-making</a></li></ul><a class="edit-page" href="https://github.com/ziotom78/Harlequin.jl/blob/master/docs/src/mapmaking.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Map-making</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Map-making-1" href="#Map-making-1">Map-making</a></h1><p>Harlequin includes a routine that applies the destriping algorithm to time-ordered data, producing a maximum-likelihood map of the intensity and polarization signal.</p><p>The destriping algorithm used in the code is described in the paper <a href="https://dx.doi.org/10.1051/0004-6361/200912361"><em>Destiping CMB temperature and polarization maps</em></a>, Kurki-Suonio et al., A/A 506, 1511-1539 (2009), and the source code closely follows the terminology introduced in that paper.</p><p>The destriping algorithm is effective in removing 1/f noise originated within the detectors of an instrument, provided that the noise is uncorrelated among detectors. It requires the user to specify a <em>baseline</em>, i.e., the maximum time span in which the noise can be assumed to be uncorrelated (i.e., white).</p><p>Since the destriper is effective only when much data is available, it is often the case that the input data to be fed to the algorithm is larger than the available memory on a machine. In this case, the destriper can take advantage of a distributed-memory environment and of the MPI libraries, if they have been loaded <em>before</em> Harlequin, like in the following example:</p><pre><code class="language-julia">import MPI
import Harlequin  # Ok, use MPI whenever possible

# ...</code></pre><p>You can check if MPI is being used with the function <a href="#Harlequin.use_mpi"><code>use_mpi</code></a>.</p><p>Destriping is based on a datatype, <a href="#Harlequin.DestripingData"><code>DestripingData</code></a>, and on the function <a href="#Harlequin.destripe!"><code>destripe!</code></a>. To use the destriper, you create an object of type <a href="#Harlequin.DestripingData"><code>DestripingData</code></a> and then call <a href="#Harlequin.destripe!"><code>destripe!</code></a> on it. The TOD must be split in a set of <em>observations</em>, using the datatype <a href="#Harlequin.Observation"><code>Observation</code></a>; we will see how to use them in the section <a href="#Splitting-a-TOD-into-observations-1">Splitting a TOD into observations</a>.</p><h2><a class="nav-anchor" id="Splitting-a-TOD-into-observations-1" href="#Splitting-a-TOD-into-observations-1">Splitting a TOD into observations</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.Observation" href="#Harlequin.Observation"><code>Harlequin.Observation</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct Observation{T &lt;: Real}</code></pre><p>An <em>observation</em> is a sequence of time-ordered data (TOD) that has been acquired by some detector. It implements the following fields:</p><ul><li><code>time</code>: an array of <code>N</code> elements, representing the time of the sample. Being defined as an <code>AbstractArray</code>, a range (e.g., <code>0.0:0.1:3600.0</code>) can be used to save memory</li><li><code>pixidx</code>: an array of <code>N</code> elements, each being a pixel index in a map. In no way the Healpix pixelization scheme is enforced; in fact, the map must not even be spherical.</li><li><code>psi_angle</code>: an array of <code>N</code> elements, each containing the orientation of the polarization angle with respect to some fixed reference system (e.g., the Ecliptic plane). The angles must be in <strong>radians</strong>.</li><li><code>tod</code>: an array of <code>N</code> elements, containing the actual data measured by the instrument and already calibrated to some physical units (e.g., K_CMB)</li><li><code>sigma_squared</code>: an array of <code>N</code> elements, containing the squared RMS of each sample. To save memory, you should usually use a <code>RunLengthArray</code> here.</li><li><code>flagged</code>: a Boolean array of <code>N</code> elements, telling whether the sample should be discarded (<code>true</code>) or not (<code>false</code>) during the map-making process.</li><li><code>name</code>: a string representing the detector. This is used only for debugging purposes.</li></ul><p>To create an observation, the constructor takes <em>keyword arguments</em> instead of parameters; in this way, the code should be more readable. Also, sensible defaults will be provided for the missing fields:</p><pre><code class="language-julia"># We do not specify &quot;sigma_squared&quot; nor &quot;flagged&quot;, so they will be
# initialized to a vector of ones and a vector of `false`
obs = Observation{Float64}(
    time = 0.0:0.1:3600.0,
    pixidx = 1:3601,
    psi_angle = zeros(3601),
    tod = randn(3601),
)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking_observations.jl#LL5-L49">source</a></section><h2><a class="nav-anchor" id="High-level-functions-1" href="#High-level-functions-1">High-level functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.DestripingData" href="#Harlequin.DestripingData"><code>Harlequin.DestripingData</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">mutable struct DestripingData{T &lt;: Real, O &lt;: Healpix.Order}</code></pre><p>Structure containing the result of a destriping operation. It contains the following fields:</p><ul><li><code>skymap</code>: a <code>PolarizedMap</code> containing the maximum-likelihood map</li><li><code>hitmap</code>: a map containing the weights of each pixel (this is not the hit count, as it is normalized over the value of <span>$σ^2$</span> for each sample in the TOD)</li><li><code>nobs_matrix</code>: an array of <a href="@ref"><code>NobsMatrixelement</code></a> objects, which can be used to determine which pixels were the most troublesome in the reconstruction of tehe I/Q/U components</li><li><code>baselines</code>: the computed baselines. These must be kept as a list of <code>RunLengthArray</code> objects</li><li><code>stopping_factors</code>: sequence of stopping factors, one for each iteration of the CG algorithm</li><li><code>threshold</code>: upper limit on the tolerable error for the Conjugated Gradient method (optional, default is <code>1e-9</code>). See <a href="#Harlequin.calc_stopping_factor"><code>calc_stopping_factor</code></a>.</li><li><code>max_iterations</code>: maximum number of allowed iterations for the Conjugated Gradient algorithm (optional, default is <code>1000</code>).</li><li><code>use_preconditioner</code>: a Boolean flag telling whether a preconditioner should be used or not (optional, default is <code>true</code>). Usually you want this to be <code>true</code>.</li></ul><p>The structure provides only one constructor, which accepts the following parameters:</p><ul><li><p><code>nside</code>: resolution of <code>skymap</code> and <code>hitmap</code></p></li><li><p><code>obs_list</code>: vector of <a href="#Harlequin.Observation"><code>Observation</code></a>; it is used to determine which pixels in the map are going to be observed</p></li><li><p><code>runs</code>: list of vectors (one for each element in <code>obs_list</code>), containing the number of samples to be included in each baseline for each observation</p></li></ul><p>The constructor accepts the following keywords as well:</p><ul><li><p><code>threshold</code> (default: <code>1e-9</code>)</p></li><li><p><code>max_iterations</code> (default: 1000)</p></li><li><p><code>use_preconditioner</code> (default: <code>true</code>)</p></li></ul><p>The function <a href="#Harlequin.destripe!"><code>destripe!</code></a> use <code>DestripingData</code> to return the result of its computation.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking_destripingdata.jl#LL6-L55">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.destripe!" href="#Harlequin.destripe!"><code>Harlequin.destripe!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">destripe!(obs_list, destriping_data::DestripingData{T,O}; comm, unseen, callback) where {T &lt;: Real, O &lt;: Healpix.Order}</code></pre><p>Apply the destriping algorithm to the TOD in <code>obs_list</code>. The result is returned in <code>destriping_data</code>, which is of type <a href="#Harlequin.DestripingData"><code>DestripingData</code></a> and contains the baselines, I/Q/U maps, weight map, etc.</p><p>The parameters must satisfy the following constraints:</p><ul><li><code>obs_list</code> must be an array of <code>N</code> <a href="#Harlequin.Observation"><code>Observation</code></a> objects;</li><li><code>destriping_data</code> must be a <a href="#Harlequin.DestripingData"><code>DestripingData</code></a> object. It does not need to have been initialized using <a href="#Harlequin.reset_maps!"><code>reset_maps!</code></a>.</li></ul><p>The optional keyword have the following meaning and default value:</p><ul><li><code>comm</code> is a MPI communicator object, or <code>nothing</code> is MPI is not used.</li><li><code>unseen</code> is the value to be used for pixels in the map that have not been observed. The default is <code>missing</code>; other sensible values are <code>nothing</code> and <code>NaN</code>.</li><li><code>callback</code> is either <code>nothing</code> (the default) or a function that is called before the CG algorithm starts, and then once every iteration. It can be used to monitor the progress of the destriper, or to save intermediate results in a database or a file. The function receives <code>destriping_data</code> as its parameter</li></ul><p>The function uses Julia&#39;s <code>Logging</code> module. Therefore, you can enable the output of diagnostic messages as usual; consider the following example:</p><pre><code class="language-julia">global_logger(ConsoleLogger(stderr, Debug))

# This command is going to produce a lot of output…
destripe!(...)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking.jl#LL529-L567">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.use_mpi" href="#Harlequin.use_mpi"><code>Harlequin.use_mpi</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">use_mpi()</code></pre><p>Return <code>true</code> if Harlequin is taking advantage of MPI, <code>false</code> if not.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/Harlequin.jl#LL17-L22">source</a></section><h2><a class="nav-anchor" id="Low-level-functions-1" href="#Low-level-functions-1">Low-level functions</a></h2><p>The following functions are listed here for reference. You are not expected to use them, unless you want to debug the destriper or dig into its internals.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.update_nobs!" href="#Harlequin.update_nobs!"><code>Harlequin.update_nobs!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update_nobs!(nobs::NobsMatrixElement{T}; threshold = 1e-7)</code></pre><p>This function makes sure that all the elements in <code>nobs</code> are synchronized. It should be called whenever the field <code>nobs.m</code> (matrix M_p in Eq. 10 of KurkiSuonio2009) has changed.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking_nobsmatrixelement.jl#LL87-L94">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.update_nobs_matrix!" href="#Harlequin.update_nobs_matrix!"><code>Harlequin.update_nobs_matrix!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update_nobs_matrix!(nobs_matrix::Vector{NobsMatrixElement{T}}, psi_angle, sigma_squared, pixidx, flagged)</code></pre><p>Apply Eq. (10) of KurkiSuonio2009 iteratively on the samples of a TOD to update matrices <span>$M_p$</span> in <code>nobs_matrix</code>. The meaning of the parameters is the following:</p><ul><li><code>nobs_matrix</code> is the structure that gets updated by this function</li><li><code>psi_angle</code> is an array of <code>N</code> elements, containing the polarization angles (in radians)</li><li><code>sigma_squared</code> is an array of <code>N</code> elements, each containing the value of σ^2 for the samples in the TOD</li><li><code>pixidx</code> is an array of <code>N</code> elements, containing the pixel index observed by the TOD</li><li><code>flagged</code> is a Boolean array of <code>N</code> elements; <code>true</code> means that the sample in the TOD should not be used to produce the map. This can be used to produce jackknives and to neglect moving objects in the TOD</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking_nobsmatrixelement.jl#LL108-L126">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.compute_nobs_matrix!" href="#Harlequin.compute_nobs_matrix!"><code>Harlequin.compute_nobs_matrix!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_nobs_matrix!(nobs_matrix::Vector{NobsMatrixElement}, observations::Vector{Observation{T}})</code></pre><p>Initialize all the elements in <code>nobs_matrix</code> so that they are the matrices M_p in Eq. (10) of KurkiSuonio2009. The TOD is taken from the list of observations in the parameter <code>observations</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking.jl#LL40-L47">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.update_binned_map!" href="#Harlequin.update_binned_map!"><code>Harlequin.update_binned_map!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">update_binned_map!(vec, skymap::PolarizedMap{T, O}, hitmap::Healpix.Map{T, O}, obs::Observation{T}; comm=nothing, unseen=NaN) where {T &lt;: Real, O &lt;: Healpix.Order}
update_binned_map!(skymap::PolarizedMap{T, O}, hitmap::Healpix.Map{T, O}, obs::Observation{T}; comm=nothing, unseen=NaN) where {T &lt;: Real, O &lt;: Healpix.Order}
update_binned_map!(skymap::PolarizedMap{T, O}, hitmap::Healpix.Map{T, O}, obs_list::Vector{Observation{T}}; comm=nothing, unseen=NaN) where {T &lt;: Real, O &lt;: Healpix.Order}</code></pre><p>Apply Eqs. (18), (19), and (20) to compute the values of I, Q, and U from a TOD, and save the result in <code>skymap</code> and <code>hitmap</code>.</p><p>The three versions differ for the source of the TOD calibrated data:</p><ul><li>if the <code>vec</code> parameter is present (first form), it will be used instead of <code>obs.tod</code> (second form)</li><li>instead of <code>obs</code> (a single <a href="#Harlequin.Observation"><code>Observation</code></a> object), you can pass an array <code>obs_list</code> (third form). All the elements in this array will be used to update <code>skymap</code> and <code>hitmap</code>.</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking.jl#LL167-L183">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.reset_maps!" href="#Harlequin.reset_maps!"><code>Harlequin.reset_maps!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reset_maps!(d::DestripingData{T, O}) where {T &lt;: Real, O &lt;: Healpix.Order}</code></pre><p>Set the skymap and the hitmap in <code>d</code> to zero. Nothing is done on the other fields.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking_destripingdata.jl#LL145-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.compute_z_and_subgroup!" href="#Harlequin.compute_z_and_subgroup!"><code>Harlequin.compute_z_and_subgroup!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_z_and_subgroup!(dest_baselines, vec, baseline_lengths, destriping_data::DestripingData{T, O}, obs::Observation{T}; comm=nothing, unseen=NaN) where {T, O &lt;: Healpix.Order}
compute_z_and_subgroup!(dest_baselines, baseline_lengths, destriping_data::DestripingData{T, O}, obs::Observation{T}; comm=nothing, unseen=NaN) where {T, O &lt;: Healpix.Order}</code></pre><p>Compute the application of matrix <span>$A$</span> in Eq. (25) in KurkiSuonio2009. The result is a set of baselines, and it is saved in <code>dest_baselines</code> (an array of elements whose type is <code>T</code>). The two forms differ only in the presence of the <code>vec</code> parameter: if it is not present, the value of <code>obs.tod</code> will be used.</p><p>This function only operates on single observations. If you want to apply it to an array of observations, use <a href="#Harlequin.compute_z_and_group!"><code>compute_z_and_group!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking.jl#LL256-L270">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.compute_z_and_group!" href="#Harlequin.compute_z_and_group!"><code>Harlequin.compute_z_and_group!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_z_and_group!(dest_baselines, vectors, baseline_lengths, destriping_data::DestripingData{T, O}, obs_list::Vector{Observation{T}}; comm=nothing, unseen=NaN) where {T, O &lt;: Healpix.Order}
compute_z_and_group!(dest_baselines, baseline_lengths, destriping_data::DestripingData{T, O}, obs_list::Vector{Observation{T}}; comm=nothing, unseen=NaN) where {T, O &lt;: Healpix.Order}</code></pre><p>Compute the application of matrix <span>$A$</span> in Eq. (25) in KurkiSuonio2009. The result is a set of baselines, and it is saved in <code>dest_baselines</code> (an array of elements whose type is <code>T</code>). The two forms differ only in the presence of the <code>vec</code> parameter: if it is not present, the value of <code>obs.tod</code> will be used.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking.jl#LL352-L362">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.compute_residuals!" href="#Harlequin.compute_residuals!"><code>Harlequin.compute_residuals!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">compute_residuals!(residuals, baseline_lengths, destriping_data, obs_list; comm=nothing, unseen=missing)</code></pre><p>This function is used to compute the value of <span>$A x - b$</span> at the beginning of the Conjugated-Gradient algorithm implemented in <a href="#Harlequin.destripe!"><code>destripe!</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking.jl#LL367-L374">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.array_dot" href="#Harlequin.array_dot"><code>Harlequin.array_dot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">array_dot(x, y; comm = nothing)</code></pre><p>Compute the dot product between <code>x</code> and <code>y</code>, assuming that both are arrays of arrays.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking.jl#LL438-L444">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.calc_stopping_factor" href="#Harlequin.calc_stopping_factor"><code>Harlequin.calc_stopping_factor</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">calc_stopping_factor(r; comm=nothing)</code></pre><p>Calculate the stopping factor required by the Conjugated Gradient method to determine if the iteration must be stopped or not. The parameter <code>r</code> is the vector of the residuals.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking.jl#LL447-L454">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.apply_offset_to_baselines!" href="#Harlequin.apply_offset_to_baselines!"><code>Harlequin.apply_offset_to_baselines!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">apply_offset_to_baselines!(baselines)</code></pre><p>Add a constant offset to all the baselines such that their sum is zero.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking.jl#LL459-L464">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Harlequin.calculate_cleaned_map!" href="#Harlequin.calculate_cleaned_map!"><code>Harlequin.calculate_cleaned_map!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">calculate_cleaned_map!(obs_list, destriping_data; comm=nothing, unseen=missing)</code></pre><p>Provided a set of baselines in <code>baselines</code>, this function cleans the TOD in <code>obs_list</code> and computes the I/Q/U maps, which are saved in <code>destriping_data</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/ziotom78/Harlequin.jl/blob/b5afa1af0448337beb49b24df18aebb23234d872/src/mapmaking.jl#LL482-L489">source</a></section><footer><hr/><a class="previous" href="../genpointings/"><span class="direction">Previous</span><span class="title">Pointing generation</span></a><a class="next" href="../examples/"><span class="direction">Next</span><span class="title">Practical examples</span></a></footer></article></body></html>
